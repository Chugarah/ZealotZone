import { getDate } from "vanilla-calendar-pro/utils";

/**
 * Form helpers
 * Got Assisted by Phind AI and documentation from Vanilla Calendar Pro
 * and Preline. This one displays the date in Swedish format in the input field
 * @returns {void}
 */

/**
 * Formats all date pickers on the page to display dates in a user-friendly format
 * This function handles multiple date pickers with the class "hs-datepicker"
 * @returns {void}
 */
function formatDatePicker() {
	const datePickers = document.querySelectorAll(".hs-datepicker");

	for (const inputElement of datePickers) {
		// Get the date picker element
		const { element } = HSDatepicker.getInstance(inputElement, true);

		// Listen for the change event
		element.on("change", (data) => {
			// If the date is selected, log the date
			if (data.selectedDates[0]) {
				// Get the date string
				const dateString = data.selectedDates[0];
				// Get the date object
				// https://vanilla-calendar.pro/docs/reference/utilities
				const dateObject = getDate(dateString);
				// Format the date
				const formattedDate = dateObject.toLocaleDateString("en-US", {
					month: "long",
					day: "numeric",
					year: "numeric",
				});

				// Set the value of the date picker
				inputElement.value = formattedDate;
			}
		});
	}
}

/**
 * Resets the datepicker year selector to show the current year
 */
function resetDatePickerYear() {
	const datePickers = document.querySelectorAll(".hs-datepicker");

	for (const inputElement of datePickers) {
		inputElement.addEventListener("click", (data) => {
			// Get the date picker element
			const { element } = HSDatepicker.getInstance(inputElement, true);

			if (element) {
				setTimeout(() => {
					console.log(element);
					const getDateSelector = inputElement.querySelector(
						".form-date-picker-years",
					);
					console.log(getDateSelector);
				}, 1000);
			}
		});
	}
}

// TODO: Implement File size limitation or Canvas/Cropping Library or both :D
function avatarUploader(config) {
	return {
		imageUrl: config.initialImageUrl || "",
		inputId: config.inputid || null,

		// Show preview of image
		showPreview(event) {
			// Get the selected file and the preview element
			const file = event.target.files[0];
			// Get the preview element
			const previewElement = this.$refs.preview;

			// Check if file is selected and preview element exists
			if (file && previewElement) {
				// Create a URL for the selected file
				const reader = new FileReader();
				reader.onload = (e) => {
					// Update the imageUrl property, which is bound to the :src of the img tag
					this.imageUrl = e.target.result;
				};
				// Read the file as a data URL
				reader.readAsDataURL(file);
			} else {
				// If no file is selected, reset the image to the initial URL
				this.imageUrl = config.initialImageUrl || "";
			}
		},
	};
}

/**
 * Alpine.js component logic for handling form validation via AJAX.
 * This code is based on the following webiste
 * Got assisted to finish and refactor this code using Google Gemini Pro
 * https://alpine-ajax.js.org/
 * https://github.com/imacrayon/alpine-ajax
 * https://technotrampoline.com/articles/building-an-ajax-form-with-alpinejs/
 * https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
 * https://plbonneville.com/blog/sending-an-anti-forgery-token-with-asp.net-core-mvc-ajax-requests/
 * https://github.com/colinaut/alpinejs-plugin-simple-validate
 * https://fabform.io/a/alpinejs-validate/
 * https://www.w3schools.com/TAGS/att_input_pattern.asp
 * @param {object} config - Configuration object.
 * @param {object} config.initialData - Initial form data.
 * @param {string} config.validationEndpoint - URL for the validation endpoint.
 * @param {string} config.antiforgeryToken - The anti-forgery token.
 * @returns {object} Alpine.js component object.
 */

// This method is depricated, will be removed next update
// Just want to try the generic ajaxFormValidation before
function memberFormValidation(config) {
	return {
		formData: {
			FirstName: config.initialData?.FirstName ?? null,
			LastName: config.initialData?.LastName ?? null,
			EmailAddress: config.initialData?.EmailAddress ?? null,
			PhoneNumber: config.initialData?.PhoneNumber ?? null,
			JobTitle: config.initialData?.JobTitle ?? null,
			Adress: config.initialData?.Adress ?? null,
			// Match the actual input names generated by the Editor Template
			"BirthDate.Day": config.initialData?.BirthDate?.Day ?? null,
			"BirthDate.Month": config.initialData?.BirthDate?.Month ?? null,
			"BirthDate.Year": config.initialData?.BirthDate?.Year ?? null,
			// We are handling our Avatar file upload below, not needed in the formdata :D and also its value isnt managed using x-model (Alpinejs)
			// Avatar: config.initialData?.Avatar ?? null
		},
		loadingFields: {},
		errors: {},
		validationEndpoint: config.validationEndpoint,
		antiforgeryToken: config.antiforgeryToken,
		isSubmitting: false,

		// Helper function to update validation UI for a field
		// This clode block was 100% generated by Google Gemini Pro
		// This function updates the validation UI for a specific field based on the
		// provided error message by finding the corresponding input, span, and icon elements.
		updateValidationUI(fieldName, errorMessages = null) {
			// Renamed parameter
			const form = this.$refs.addMemberForm;
			if (!form) return;

			const inputElement = form.elements[fieldName];
			const validationSpan =
				form.querySelector(`#error-msg-${fieldName}`) ||
				form.querySelector(`[data-valmsg-for="${fieldName}"]`);
			const iconElement = this.$refs[`${fieldName}IconRef`];

			// Determine if there are errors based on the array
			const hasErrors = errorMessages && errorMessages.length > 0;

			if (inputElement) {
				if (hasErrors) {
					inputElement.classList.add("input-validation-error");
					inputElement.classList.add("field-validation-invalid");
					inputElement.classList.remove("field-validation-valid");
					inputElement.setAttribute("aria-invalid", "true");
				} else {
					inputElement.classList.remove("input-validation-error");
					inputElement.classList.add("field-validation-valid");
					inputElement.classList.remove("field-validation-invalid");
					inputElement.removeAttribute("aria-invalid");
				}
			}
			if (validationSpan) {
				// Join the array of messages with a newline character
				validationSpan.textContent = hasErrors
					? errorMessages.map((msg) => `• ${msg}`).join("\n")
					: "";

				if (hasErrors) {
					validationSpan.removeAttribute("hidden");
					validationSpan.classList.add("field-validation-invalid");
					validationSpan.classList.remove("field-validation-valid");
				} else {
					validationSpan.setAttribute("hidden", "");
					validationSpan.classList.remove("field-validation-invalid");
					validationSpan.classList.add("field-validation-valid");
				}
			}

			if (iconElement) {
				iconElement.style.display = hasErrors ? "inline-block" : "none";
			}
		},

		/**
		 * This Code was 100% generated by Google Gemini Pro
		 * Generic function to validate a group of related fields.
		 * Handles "all or none" requirements and runs custom validation logic if all are filled.
		 * @param {string[]} fieldNames - Array of field names belonging to the group.
		 * @param {string} allOrNoneMessage - Error message if the "all or none" rule is violated.
		 * @param {function|null} groupValidationLogic - A callback function that receives an object
		 *                                               with fieldName:value pairs for the group.
		 *                                               It should return null if valid, or an array
		 *                                               of error messages if invalid. Can be null
		 *                                               if only the "all or none" check is needed.
		 * @param {string} [unselectedValue="0"] - The value representing an unselected state. Also checks for empty string.
		 * @returns {boolean} - True if the group is valid, false otherwise.
		 */
		validateFieldGroup(
			fieldNames,
			allOrNoneMessage,
			groupValidationLogic,
			unselectedValue = "0",
		) {
			let selectedCount = 0;
			const groupValues = {};
			let groupErrorMessages = null;
			let isGroupValid = true;

			// 1. Count selected fields and gather values
			for (const fieldName of fieldNames) {
				const value = this.formData[fieldName];
				groupValues[fieldName] = value; // Store value for the callback
				if (value && value !== unselectedValue && String(value).trim() !== "") {
					selectedCount++;
				}
			}

			const allSelected = selectedCount === fieldNames.length;
			const noneSelected = selectedCount === 0;

			// 2. Check "all or none" rule
			if (!allSelected && !noneSelected) {
				isGroupValid = false;
				groupErrorMessages = [allOrNoneMessage];
			}
			// 3. If all selected and custom logic exists, run it
			else if (allSelected && typeof groupValidationLogic === "function") {
				const validationResult = groupValidationLogic(groupValues);
				if (
					validationResult !== null &&
					Array.isArray(validationResult) &&
					validationResult.length > 0
				) {
					isGroupValid = false;
					groupErrorMessages = validationResult;
				}
			}

			// 4. Update UI and error state for all fields in the group
			for (const fieldName of fieldNames) {
				this.updateValidationUI(
					fieldName,
					isGroupValid ? null : groupErrorMessages,
				);

				if (!isGroupValid) {
					this.errors[fieldName] = groupErrorMessages;
				} else {
					// Clear potential *group* error if the group is now valid.
					// Check if the existing error message matches the potential group error messages.
					const currentError = this.errors[fieldName]?.[0];
					const potentialGroupError1 = allOrNoneMessage;
					// We need a way to compare the specific validation error message if groupValidationLogic was used.
					// This comparison is tricky without knowing the exact error message beforehand.
					// A simpler approach for now: If the group becomes valid, clear errors for its fields,
					// assuming individual validation will re-add errors if needed.
					// Refinement: Only delete if the error seems to be *this* group's error.
					if (
						this.errors[fieldName] &&
						currentError ===
							potentialGroupError1 /* || check against specific logic error */
					) {
						delete this.errors[fieldName];
					}
					// If groupValidationLogic exists, we might need a more robust way to identify its specific error message later.
				}
			}

			return isGroupValid;
		},

		/**
		 * This code was Refactored by Google Gemini Pro
		 * Specific validation logic callback for the Birth Date group.
		 * @param {object} values - Object containing { "BirthDate.Day": value, "BirthDate.Month": value, "BirthDate.Year": value }
		 * @returns {string[]|null} - Array with error message if invalid, null if valid.
		 */
		birthDateValidationCallback(values) {
			const dayField = "BirthDate.Day";
			const monthField = "BirthDate.Month";
			const yearField = "BirthDate.Year";

			// Values are already checked to be non-empty/non-default by validateFieldGroup
			const dayNumber = Number.parseInt(values[dayField], 10);
			const monthNumber = Number.parseInt(values[monthField], 10);
			const yearNumber = Number.parseInt(values[yearField], 10);
			const currentYear = new Date().getFullYear();

			// Check parsing results just in case
			// Code block validating proper date was generated by Google Gemini Pro 100%
			if (
				Number.isNaN(dayNumber) ||
				Number.isNaN(monthNumber) ||
				Number.isNaN(yearNumber)
			) {
				return ["Invalid numeric value for Day, Month, or Year."]; // Should ideally not happen with selects
			}

			const dateObj = new Date(yearNumber, monthNumber - 1, dayNumber); // JS month is 0-indexed

			if (
				dateObj.getFullYear() !== yearNumber ||
				dateObj.getMonth() !== monthNumber - 1 ||
				dateObj.getDate() !== dayNumber || // Check for invalid dates (e.g., Feb 30)
				yearNumber < 1900 ||
				yearNumber > currentYear // Optional: Year range check
			) {
				return ["The selected Day, Month, and Year do not form a valid date."];
			}

			return null; // Date is valid
		},

		extentedValidator(fieldName) {
			// Getting the form
			const form = this.$refs.addMemberForm;
			if (!form) return;

			// Getting the input element data
			const inputElement = form.elements[fieldName];
			const inputValues = inputElement.value;
			const inputDataset = inputElement.dataset;
			// Define the value representing an unselected state (adjust if needed)
			const unselectedValue = null;

			if (!inputElement) return;

			// Validation Rules
			// Add more validation rules here based on your Dataanotation rules

			// --- Define Field Groups ---
			const groups = {
				birthDate: {
					fields: ["BirthDate.Day", "BirthDate.Month", "BirthDate.Year"],
					allOrNoneMessage:
						"Please provide all parts of the birth date (Day, Month, Year) or leave all blank.",
					validationCallback: this.birthDateValidationCallback.bind(this),
					unselectedValue: null,
				},
			};

			let isFieldValid = true; // Assume valid by default
			let fieldBelongsToGroup = false;

			// --- Check if the field belongs to any defined group ---
			for (const groupName in groups) {
				const group = groups[groupName];
				if (group.fields.includes(fieldName)) {
					fieldBelongsToGroup = true;
					// Delegate validation entirely to the group validator
					isFieldValid = this.validateFieldGroup(
						group.fields,
						group.allOrNoneMessage,
						group.validationCallback,
						group.unselectedValue,
					);
					// If we foiund the group, we can break the loop
					break;
				}
			}

			if (!fieldBelongsToGroup) {
				// === Individual Validation Rules ===
				// Resetting Error array
				const inputErrors = [];

				// === Required ===
				// Required Check
				if (
					inputDataset.valRequired &&
					(!inputValues ||
						inputValues === unselectedValue ||
						String(inputValues).trim() === "")
				) {
					inputErrors.push(inputDataset.valRequired);
				}

				// === MinLength ===
				// MinLength Check (only if value exists and is not just whitespace)
				if (
					inputDataset.valMinlength &&
					inputValues &&
					String(inputValues).trim() !== "" &&
					inputValues.length < Number.parseInt(inputDataset.valMinlengthMin, 10)
				) {
					if (inputValues.length > 0) {
						// Only show length error if something is entered
						inputErrors.push(inputDataset.valMinlength);
					}
				}

				// === MaxLength ===
				// We are checking if the input has a maxlength attribute and if the length o
				// f the input is greater than the maxlength
				// This message wont be reach becouse of the maxlength attribute
				if (
					inputDataset.valLength &&
					inputValues.length > Number.parseInt(inputDataset.valLengthMax, 10)
				) {
					inputErrors.push(inputDataset.valLength);
				} else if (
					inputDataset.valMaxlength &&
					inputValues.length > Number.parseInt(inputDataset.valMaxlengthMax, 10)
				) {
					inputErrors.push(inputDataset.valMaxlength);
				}

				// === Range ===
				// This code Range block is gnereated 100% using Google Gemini Pro
				// We are checking if the input has a range attribute and if the value is within the range
				if (
					inputDataset.valRange &&
					inputDataset.valRangeMin &&
					inputDataset.valRangeMax &&
					inputValues &&
					inputValues !== unselectedValue &&
					String(inputValues).trim() !== ""
				) {
					const numValue = Number.parseFloat(inputValues);
					const min = Number.parseFloat(inputDataset.valRangeMin);
					const max = Number.parseFloat(inputDataset.valRangeMax);
					if (Number.isNaN(numValue) || numValue < min || numValue > max) {
						inputErrors.push(inputDataset.valRange);
					}
				}

				// === Regex ===
				// We are checking if the input has a regex attribute and if the value matches the regex
				if (inputDataset.valRegex && inputDataset.valRegexPattern) {
					const regex = new RegExp(inputDataset.valRegexPattern);
					if (inputValues && !regex.test(inputValues)) {
						// Only test if value exists
						inputErrors.push(inputDataset.valRegex);
					}
				}

				// --- Update errors state and UI ---
				if (inputErrors.length > 0) {
					this.errors[fieldName] = inputErrors;
					this.updateValidationUI(fieldName, inputErrors);
					isFieldValid = false;
				} else {
					// Clear previous errors for this specific field if it's now valid
					if (this.errors[fieldName]) {
						delete this.errors[fieldName];
						this.updateValidationUI(fieldName, null);
					}
					isFieldValid = true;
				}
			}
			return isFieldValid;
		},

		// Validate the entire form
		validateEntireForm() {
			let isFormValid = true;
			// Validate each field. If any field is invalid, the whole form is invalid.
			// The '&&' ensures that isFormValid becomes false if any validation fails
			// and stays false.
			for (const fieldName of Object.keys(this.formData)) {
				const isFieldValid = this.extentedValidator(fieldName);
				isFormValid = isFieldValid && isFormValid;
			}

			// === Group Birthdate ===
			// Time to do my first group validation and I choose you Birthdate :)
			const day = this.formData["BirthDate.Day"];
			const month = this.formData["BirthDate.Month"];
			const year = this.formData["BirthDate.Year"];

			// checks if birth day values nor 0, null and has value
			const birthDateFieldsSelected =
				day &&
				day !== "0" &&
				day !== null &&
				month &&
				month !== "0" &&
				month !== null &&
				year &&
				year !== "0" &&
				year !== null;

			if (birthDateFieldsSelected) {
				// Getting numeric values
				const dayNumber = Number.parseInt(day, 10);
				const monthNumber = Number.parseInt(month, 10); // 1-12
				const yearNumber = Number.parseInt(year, 10);
				const currentYear = new Date().getFullYear();

				// Validate the actual date using the Date object.
				// JavaScript months are 0-indexed (0-11).
				// Asked Google Gemeni to generate the code block that validates
				// correct date, example Feb 30th becomes Mars 2n
				// https://stackoverflow.com/questions/36179804/javascript-date-allows-invalid-data-e-g-feb-30th
				// https://stackoverflow.com/questions/15799514/why-does-javascript-getmonth-count-from-0-and-getdate-count-from-1/68452856
				const dateObj = new Date(yearNumber, monthNumber - 1, dayNumber);

				let isCombinedDateValid = true;
				let birthDateErrorMessage = null;

				// Check for date validity (e.g., Feb 30th becomes Mar 2nd)
				if (
					dateObj.getFullYear() !== yearNumber ||
					dateObj.getMonth() !== monthNumber - 1 || // Compare with 0-indexed month
					dateObj.getDate() !== dayNumber
				) {
					isCombinedDateValid = false;
					birthDateErrorMessage = ["The selected date does not exist."];
				}

				// If the combined date check failed, update UI and overall form validity
				if (!isCombinedDateValid) {
					this.updateValidationUI(dayField, birthDateErrorMessage);
					this.updateValidationUI(monthField, birthDateErrorMessage);
					this.updateValidationUI(yearField, birthDateErrorMessage);
					isFormValid = false;
				}
			}

			return isFormValid;
		},

		// Lets start with CLientside validation before sending it further
		async validateField(fieldName) {
			// Wait for the next tick to ensure the validation has been applied
			this.$nextTick(() => {
				this.extentedValidator(fieldName);
			});
		},

		// Submit the form using Alpine.js Ajax
		async submitForm() {
			// Lets prevent mutiple submissions
			if (this.isSubmitting) {
				return;
			}

			// First lets run client side validation
			// This code block was Generated by Google Gemini Pro
			if (!this.validateEntireForm()) {
				console.log("Client-side validation failed. Submission stopped.");
				// Optional: Focus the first invalid field
				const firstErrorField = Object.keys(this.errors)[0];
				if (
					firstErrorField &&
					this.$refs.addMemberForm.elements[firstErrorField]
				) {
					try {
						this.$refs.addMemberForm.elements[firstErrorField].focus();
					} catch (e) {
						console.warn(`Could not focus on field: ${firstErrorField}`, e);
					}
				}
				return; // Stop submission if validation fails
			}

			// Set Submitting to true
			this.isSubmitting = true;
			// Clear previous errors (UI and state)
			this.errors = {};
			// Clear UI for all potential fields in formData
			for (const fieldName of Object.keys(this.formData)) {
				this.updateValidationUI(fieldName, null);
			}

			// Disabling Button and Showing Spinner

			// === Preparing Data ===
			const payLoad = new FormData();

			// Append each key-value pair to the FormData object
			// Inspired by Google Gemini Pro that helped me solved
			// the issue with the avatar regarding Ajax Fetch Post
			for (const key in this.formData) {
				// Lets Skipp Avatar from the standard inputs
				if (key !== "Avatar") {
					const value = this.formData[key];

					// Google Gemini Pro refactorered if statement
					// We are checkking if the value is not null, undefined or empty
					// and we are also triming the value to remove any whitespace
					if (
						value !== null &&
						value !== undefined &&
						String(value).trim() !== ""
					) {
						payLoad.append(key, value);
					}
				}
			}

			// === File Upload ===
			// Get the Avatar input element using Alpine.js
			const avatarInput = this.$refs.addMemberForm.elements.Avatar;
			// Lets check if the Avatar input has a file
			if (avatarInput?.files?.length > 0) {
				// Append the file to the FormData object
				payLoad.append("Avatar", avatarInput.files[0]);
			} else {
				payLoad.append("Avatar", null);
			}

			try {
				// Adding a delay to simulate a slow network connection
				await new Promise((r) => setTimeout(r, 5000));
				const ajaxResponce = await fetch(this.validationEndpoint, {
					method: "POST",
					headers: {
						RequestVerificationToken: this.antiforgeryToken,
					},
					body: payLoad,
				});

				if (!ajaxResponce.ok) {
					// Lets check for Error 400 that is most common regarding
					// validation errors

					if (ajaxResponce.status === 400) {
						const errorData = await ajaxResponce.json();

						// Lets check if we can map the errors to the form fields
						if (errorData?.errors) {
							this.errors = errorData.errors;

							// Update UI based on server errors
							for (const fieldName of Object.keys(this.errors)) {
								this.updateValidationUI(fieldName, this.errors[fieldName]);
							}
						} else {
							// If we can't map the errors to the form fields, we'll display a generic error message
							this.updateValidationUI("form", "Ajax Validation Error");
						}
					} else {
						// We need to display other errors example 500 or other server errors
						this.updateValidationUI(
							"form",
							`Server error: ${ajaxResponce.status}`,
						);
					}
				} else {
					const result = await ajaxResponce.json();
					console.log("Form submitted successfully!");
				}
			} catch (error) {
				this.updateValidationUI("form", "Could not submit form. Server error.");
			} finally {
				this.isSubmitting = false;
			}
		},
	};
}

/**
 * This Generic function is based on the memberFormValidation function
 * and has been Refactored by Google Gemeni Pro to work with multiple types of forms
 * Alpine.js component logic for handling generic form validation via AJAX.
 * @param {object} config - Configuration object.
 * @param {string} config.formRefName - The x-ref name of the form element (e.g., 'addMemberForm', 'addProjectForm').
 * @param {object} config.initialData - Initial form data (key-value pairs matching input names).
 * @param {string} config.validationEndpoint - URL for the validation endpoint.
 * @param {string} config.antiforgeryToken - The anti-forgery token.
 * @param {object} [config.groups={}] - Optional: Definitions for field groups.
 *                                      Example: { groupName: { fields: [], allOrNoneMessage: '', validationCallback: function|null, unselectedValue: '' } }
 * @param {object} [config.validationCallbacks={}] - Optional: Container for custom validation callback functions used by groups.
 * @param {string[]} [config.fileInputNames=[]] - Optional: Array of names for file input fields.
 * @param {string} [config.unselectedValue="0"] - Optional: Default value representing an unselected state for inputs like selects.
 * @returns {object} Alpine.js component object.
 */
function ajaxFormValidation(config) {
	// --- Configuration Validation ---
	if (!config.formRefName)
		throw new Error("ajaxFormValidation requires config.formRefName.");
	if (!config.initialData)
		throw new Error("ajaxFormValidation requires config.initialData.");
	if (!config.validationEndpoint)
		throw new Error("ajaxFormValidation requires config.validationEndpoint.");
	if (!config.antiforgeryToken)
		throw new Error("ajaxFormValidation requires config.antiforgeryToken.");

	// --- Initialize formData dynamically ---
	const initialFormData = {};
	for (const key in config.initialData) {
		initialFormData[key] = config.initialData[key] ?? null;
	}

	return {
		// --- Core Properties ---
		formRefName: config.formRefName,
		formData: initialFormData,
		// Use provided groups or default to empty
		groups: config.groups || {},
		// Use provided callbacks or default
		validationCallbacks: config.validationCallbacks || {},
		// Use provided file names or default
		fileInputNames: config.fileInputNames || [],
		// Default unselected value
		unselectedValue: config.unselectedValue ?? "0",
		validationEndpoint: config.validationEndpoint,
		antiforgeryToken: config.antiforgeryToken,
		errors: {},
		isSubmitting: false,
		// Keep if used elsewhere
		loadingFields: {},

		// --- Helper Methods ---
		updateValidationUI(fieldName, errorMessages = null) {
			const form = this.$refs[this.formRefName]; // Use dynamic form ref
			if (!form) return;

			const inputElement = form.elements[fieldName];
			// Use querySelector for potentially dynamic IDs/attributes
			const validationSpan =
				form.querySelector(`[data-valmsg-for="${fieldName}"]`) ||
				form.querySelector(`#error-msg-${fieldName}`);
			// Assumes icon refs follow convention, if you have Icon that should
			// be displayed along with error message
			const iconElement = this.$refs[`${fieldName}IconRef`];
			const hasErrors = errorMessages && errorMessages.length > 0;

			// Update UI based on error presence
			if (inputElement) {
				if (hasErrors) {
					inputElement.classList.add("input-validation-error");
					inputElement.classList.add("field-validation-invalid");
					inputElement.classList.remove("field-validation-valid");
					inputElement.setAttribute("aria-invalid", "true");
				} else {
					inputElement.classList.remove("input-validation-error");
					inputElement.classList.add("field-validation-valid");
					inputElement.classList.remove("field-validation-invalid");
					inputElement.removeAttribute("aria-invalid");
				}
			}
			// Update span and icon based on error presence
			if (validationSpan) {
				validationSpan.textContent = hasErrors
					? errorMessages.map((msg) => `• ${msg}`).join("\n")
					: "";
				if (hasErrors) {
					validationSpan.removeAttribute("hidden");
					validationSpan.classList.add("field-validation-invalid");
					validationSpan.classList.remove("field-validation-valid");
				} else {
					validationSpan.setAttribute("hidden", "");
					validationSpan.classList.remove("field-validation-invalid");
					validationSpan.classList.add("field-validation-valid");
				}
			}
			// Update icon display based on error presence
			if (iconElement) {
				iconElement.style.display = hasErrors ? "inline-block" : "none";
			}
		},

		// --- Validation Logic ---
		/**
		 * Validates a group of related form fields based on an "all or none" selection rule
		 * and optional custom validation logic.
		 *
		 * Dock Generated by Google Gemini Pro
		 * validateFieldGroup Helper function Was 100% generated by Google Gemini Pro
		 *
		 * Ensures that either all fields in the specified group have a selected value
		 * (not equal to `unselectedValue` and not an empty string after trimming) or none of them do.
		 * If all fields are selected and a `groupValidationLogic` function is provided,
		 * that function is executed to perform additional validation on the group's values.
		 * Updates the validation UI and the component's error state (`this.errors`) for all fields in the group.
		 *
		 * @param {string[]} fieldNames - An array of strings, where each string is the name of a field belonging to the group.
		 * @param {string} allOrNoneMessage - The error message to display if the "all or none" rule is violated (i.e., some but not all fields are selected).
		 * @param {function(Object.<string, any>): (string[]|null)} [groupValidationLogic] - An optional callback function for custom validation logic. This function is executed only if all fields in the group are selected. It receives an object containing the current values of the fields in the group (keyed by field name). It should return an array of error messages if validation fails, or `null` or an empty array if validation passes.
		 * @param {any} [unselectedValue=this.unselectedValue] - The value that represents an unselected state for a field within the group. Defaults to the component's `unselectedValue` property.
		 * @returns {boolean} Returns `true` if the field group passes validation (either all selected and custom logic passes, or none selected), `false` otherwise.
		 */
		validateFieldGroup(
			fieldNames,
			allOrNoneMessage,
			groupValidationLogic,
			unselectedValue = this.unselectedValue,
		) {
			// Initialize variables
			let selectedCount = 0;
			const groupValues = {};
			let groupErrorMessages = null;
			let isGroupValid = true;

			// Count selected fields and gather values
			for (const fieldName of fieldNames) {
				const value = this.formData[fieldName];
				groupValues[fieldName] = value; // Store value for the callback
				if (value && value !== unselectedValue && String(value).trim() !== "") {
					selectedCount++;
				}
			}

			// 1. Check if all or none are selected
			const allSelected = selectedCount === fieldNames.length;
			const noneSelected = selectedCount === 0;

			// 2. Check "all or none" rule
			if (!allSelected && !noneSelected) {
				isGroupValid = false;
				groupErrorMessages = [allOrNoneMessage];
			}

			// 3. If all selected and custom logic exists, run it
			else if (allSelected && typeof groupValidationLogic === "function") {
				// Call the validation logic function directly
				const validationResult = groupValidationLogic(groupValues);
				if (
					validationResult !== null &&
					Array.isArray(validationResult) &&
					validationResult.length > 0
				) {
					isGroupValid = false;
					groupErrorMessages = validationResult;
				}
			}

			// 4. Update UI and error state for all fields in the group
			for (const fieldName of fieldNames) {
				this.updateValidationUI(
					fieldName,
					isGroupValid ? null : groupErrorMessages,
				);

				// Update error state
				if (!isGroupValid) {
					this.errors[fieldName] = groupErrorMessages;
				} else {
					const currentError = this.errors[fieldName]?.[0];
					const potentialGroupError1 = allOrNoneMessage;
					if (this.errors[fieldName] && currentError === potentialGroupError1) {
						delete this.errors[fieldName];
					}
				}
			}
			return isGroupValid;
		},

		/**
		 * Validates a specific form field based on configured rules.
		 *
		 * Dockmentation generated by Google Gemini Pro
		 *
		 * This function checks if the field belongs to a validation group defined in `this.groups`.
		 * If it does, it delegates validation to `validateFieldGroup` using the group's configuration
		 * (fields, message, callback, unselectedValue).
		 *
		 * If the field does not belong to a group, it performs individual validation checks based on
		 * `data-val-*` attributes on the input element:
		 * - `data-val-required`: Checks if the field is required and not empty or equal to `this.unselectedValue`.
		 * - `data-val-minlength`, `data-val-minlength-min`: Checks for minimum length.
		 * - `data-val-length`, `data-val-length-max`: Checks for maximum length (alternative to maxlength).
		 * - `data-val-maxlength`, `data-val-maxlength-max`: Checks for maximum length.
		 * - `data-val-range`, `data-val-range-min`, `data-val-range-max`: Checks if a numeric value falls within a range.
		 * - `data-val-regex`, `data-val-regex-pattern`: Checks if the value matches a regular expression.
		 *
		 * Validation errors are stored in the `this.errors` object, keyed by the field name.
		 * The UI is updated via `this.updateValidationUI` to reflect the validation status.
		 *
		 * @param {string} fieldName - The name attribute of the form field to validate.
		 * @returns {boolean} True if the field is valid according to the applied rules, false otherwise.
		 */
		extendedValidator(fieldName) {
			// Getting the form and input element
			const form = this.$refs[this.formRefName];
			if (!form) return true;
			const inputElement = form.elements[fieldName];
			if (!inputElement) return true;

			// Getting the input element data
			const inputValues = inputElement.value;
			const inputDataset = inputElement.dataset;
			const currentUnselectedValue = this.unselectedValue;

			let isFieldValid = true;
			let fieldBelongsToGroup = false;

			// --- Check if the field belongs to any defined group ---
			// that being loaded from the config
			for (const groupName in this.groups) {
				const group = this.groups[groupName];

				// If the field is part of the group
				if (group.fields.includes(fieldName)) {
					fieldBelongsToGroup = true;
					// Get the actual callback function if specified
					const callbackFn =
						typeof group.validationCallback === "string"
							? this.validationCallbacks[group.validationCallback] // Look up by name if string
							: group.validationCallback; // Assume it's the function itself

					// Delegate validation entirely to the group validator
					isFieldValid = this.validateFieldGroup(
						group.fields,
						group.allOrNoneMessage,
						callbackFn, // Pass the actual function
						// Use group-specific or default unselectedValue
						group.unselectedValue ?? currentUnselectedValue,
					);
					break;
				}
			}

			// If the field does not belong to any group, perform individual validation checks
			if (!fieldBelongsToGroup) {
				const inputErrors = [];

				// === Individual Validation Rules ===
				// Required Check
				if (
					inputDataset.valRequired &&
					(!inputValues ||
						inputValues === currentUnselectedValue ||
						String(inputValues).trim() === "")
				) {
					inputErrors.push(inputDataset.valRequired);
				}

				// MinLength Check
				if (
					inputDataset.valMinlength &&
					inputValues &&
					String(inputValues).trim() !== "" &&
					inputValues.length < Number.parseInt(inputDataset.valMinlengthMin, 10)
				) {
					inputErrors.push(inputDataset.valMinlength);
				}
				// MaxLength Check
				if (
					inputDataset.valLength &&
					inputValues.length > Number.parseInt(inputDataset.valLengthMax, 10)
				) {
					inputErrors.push(inputDataset.valLength);
				} else if (
					inputDataset.valMaxlength &&
					inputValues.length > Number.parseInt(inputDataset.valMaxlengthMax, 10)
				) {
					inputErrors.push(inputDataset.valMaxlength);
				}

				// Range Check
				// This code Range block is gnereated 100% using Google Gemini Pro
				if (
					inputDataset.valRange &&
					inputDataset.valRangeMin &&
					inputDataset.valRangeMax &&
					inputValues &&
					inputValues !== currentUnselectedValue &&
					String(inputValues).trim() !== ""
				) {
					const numValue = Number.parseFloat(inputValues);
					const min = Number.parseFloat(inputDataset.valRangeMin);
					const max = Number.parseFloat(inputDataset.valRangeMax);
					if (Number.isNaN(numValue) || numValue < min || numValue > max) {
						inputErrors.push(inputDataset.valRange);
					}
				}
				// Regex Check
				if (inputDataset.valRegex && inputDataset.valRegexPattern) {
					const regex = new RegExp(inputDataset.valRegexPattern);
					if (inputValues && !regex.test(inputValues)) {
						inputErrors.push(inputDataset.valRegex);
					}
				}

				// --- Update UI and errors based on individual checks ---
				if (inputErrors.length > 0) {
					this.errors[fieldName] = inputErrors;
					this.updateValidationUI(fieldName, inputErrors);
					isFieldValid = false;
				} else {
					if (this.errors[fieldName]) {
						delete this.errors[fieldName];
						this.updateValidationUI(fieldName, null);
					}
					isFieldValid = true;
				}
			}
			return isFieldValid;
		},

		/**
		 * Dockmentation generated by Google Gemini Pro
		 * Validates all fields within the form's data object, excluding any fields listed in `this.fileInputNames`.
		 * It iterates through each field name in `this.formData`, calls `this.extendedValidator` for each non-file field,
		 * and aggregates the results to determine the overall validity of the form.
		 *
		 * @returns {boolean} True if all validated fields in the form are valid according to `extendedValidator`, false otherwise.
		 */
		validateEntireForm() {
			let isFormValid = true;
			// Iterate through each field in formData
			for (const fieldName of Object.keys(this.formData)) {
				// Skip file inputs if they exist in formData but shouldn't be validated here
				if (this.fileInputNames.includes(fieldName)) continue;

				// Validate each field and update the form's validity status
				const isFieldValid = this.extendedValidator(fieldName);
				isFormValid = isFieldValid && isFormValid;
			}
			// Note: The specific birthdate check block is removed as it's handled by groups now.
			return isFormValid;
		},

		/**
		 * Asynchronously validates a specific field after the next DOM update cycle.
		 * Dockmentation generated by Google Gemini Pro
		 * It schedules the `extendedValidator` method to run for the given field name
		 * once the Vue component has finished updating the DOM.
		 *
		 * @param {string} fieldName - The name of the field to be validated.
		 */
		async validateField(fieldName) {
			this.$nextTick(() => {
				this.extendedValidator(fieldName);
			});
		},

		/**
		 * Handles the asynchronous submission of the form associated with the component.
		 * Dockmentation generated by Google Gemini Pro
		 *
		 * Performs the following steps:
		 * 1. Prevents submission if already submitting (`this.isSubmitting`).
		 * 2. Performs client-side validation using `this.validateEntireForm()`.
		 * 3. If client-side validation fails, logs an error, focuses the first invalid field, and stops.
		 * 4. Sets `this.isSubmitting` to true and clears existing `this.errors`.
		 * 5. Resets validation UI for all fields.
		 * 6. Creates a `FormData` object (`payLoad`).
		 * 7. Appends non-file fields from `this.formData` to `payLoad`, skipping empty values.
		 * 8. Appends files from file inputs specified in `this.fileInputNames` to `payLoad`.
		 * 9. Sends the `payLoad` to `this.validationEndpoint` using a POST request via `fetch`.
		 * 10. Includes the `RequestVerificationToken` header using `this.antiforgeryToken`.
		 * 11. Handles the server response:
		 *     - If the response is not OK (e.g., status 400), attempts to parse JSON error data.
		 *     - Updates `this.errors` and the validation UI based on server-returned errors.
		 *     - Displays generic error messages for non-400 errors or unknown validation issues.
		 *     - If the response is OK, parses the JSON result and logs success. (Success handling like redirection might be implemented here).
		 * 12. Catches network or other fetch errors, logs them, and updates the UI with a generic submission error.
		 * 13. Finally, sets `this.isSubmitting` back to false.
		 *
		 * Relies on component properties: `isSubmitting`, `errors`, `formRefName`, `formData`,
		 * `fileInputNames`, `validationEndpoint`, `antiforgeryToken`.
		 * Relies on component methods: `validateEntireForm`, `updateValidationUI`.
		 *
		 * @async
		 * @function submitForm
		 * @returns {Promise<void>} A promise that resolves when the submission process (including handling the response) is complete.
		 */
		async submitForm() {
			if (this.isSubmitting) return;

			// Client-side validation
			if (!this.validateEntireForm()) {
				console.log("Client-side validation failed. Submission stopped.");
				const firstErrorField = Object.keys(this.errors)[0];
				const formElement = this.$refs[this.formRefName];
				// Focus on the first invalid field
				if (firstErrorField && formElement?.elements[firstErrorField]) {
					try {
						formElement.elements[firstErrorField].focus();
					} catch (e) {
						console.warn(`Could not focus on field: ${firstErrorField}`, e);
					}
				}
				return;
			}

			// Prepare for submission, clear UI
			this.isSubmitting = true;
			this.errors = {};
			for (const fieldName of Object.keys(this.formData)) {
				this.updateValidationUI(fieldName, null);
			}

			// Prepare payload and getting form data
			const payLoad = new FormData();
			const formElement = this.$refs[this.formRefName];

			// Append standard form data
			for (const key in this.formData) {
				// Skip file inputs here, handle them separately
				if (!this.fileInputNames.includes(key)) {
					const value = this.formData[key];
					if (
						value !== null &&
						value !== undefined &&
						String(value).trim() !== ""
					) {
						payLoad.append(key, value);
					}
				}
			}

			// Append file uploads based on config
			// === File Upload ===
			for (const fileName of this.fileInputNames) {
				const fileInput = formElement.elements[fileName];
				if (fileInput?.files?.length > 0) {
					payLoad.append(fileName, fileInput.files[0]);
				} 
			}

			// Submit the form
			try {
				await new Promise((r) => setTimeout(r, 3000)); // Optional delay
				const ajaxResponse = await fetch(this.validationEndpoint, {
					// Corrected variable name
					method: "POST",
					headers: {
						RequestVerificationToken: this.antiforgeryToken,
					},
					body: payLoad,
				});

				// Handle response
				if (!ajaxResponse.ok) {
					// Corrected variable name
					if (ajaxResponse.status === 400) {
						// Corrected variable name
						const errorData = await ajaxResponse.json(); // Corrected variable name
						if (errorData?.errors) {
							this.errors = errorData.errors;
							for (const fieldName of Object.keys(this.errors)) {
								this.updateValidationUI(fieldName, this.errors[fieldName]);
							}
						} else {
							this.updateValidationUI(this.formRefName, [
								"An unknown validation error occurred.",
							]); // Use formRefName for generic form errors
						}
					} else {
						this.updateValidationUI(this.formRefName, [
							`Server error: ${ajaxResponse.status}`,
						]); // Corrected variable name
					}
				} else {
					const result = await ajaxResponse.json(); // Corrected variable name
					console.log("Form submitted successfully!", result);
					// Handle success (e.g., redirect, display message)
					// Example: window.location.href = result.redirectUrl;
				}
			} catch (error) {
				console.error("Form submission error:", error);
				this.updateValidationUI(this.formRefName, [
					"Could not submit form. Network or server error.",
				]);
			} finally {
				this.isSubmitting = false;
			}
		},
	};
}


/**
 * Validates a birth date provided as separate day, month, and year values.
 * Documentation Generated by Google Gemini Pro
 * Code block refactored by Google Gemini Pro
 *
 * Checks if the day, month, and year are valid numbers, form a valid calendar date,
 * and fall within a reasonable range (Year >= 1900 and Year <= current year).
 *
 * @param {Object.<string, string>} values - An object containing the form values, expected to have properties 'BirthDate.Day', 'BirthDate.Month', and 'BirthDate.Year' as strings.
 * @returns {string[] | null} An array containing error messages if validation fails, otherwise null.
 */
function birthDateValidationCallback(values) {
    const dayField = "BirthDate.Day";
    const monthField = "BirthDate.Month";
    const yearField = "BirthDate.Year";
    const dayNumber = Number.parseInt(values[dayField], 10);
    const monthNumber = Number.parseInt(values[monthField], 10);
    const yearNumber = Number.parseInt(values[yearField], 10);
    const currentYear = new Date().getFullYear();

	// Validate the actual date using the Date object.
    if (Number.isNaN(dayNumber) || Number.isNaN(monthNumber) || Number.isNaN(yearNumber)) {
        return ["Invalid numeric value for Day, Month, or Year."];
    }
	// JavaScript months are 0-indexed (0-11).
	// https://stackoverflow.com/questions/2552483/why-does-the-month-argument-range-from-0-to-11-in-javascripts-date-constructor
	// https://stackoverflow.com/questions/36179804/javascript-date-allows-invalid-data-e-g-feb-30th
	// https://stackoverflow.com/questions/15799514/why-does-javascript-getmonth-count-from-0-and-getdate-count-from-1/68452856
    const dateObj = new Date(yearNumber, monthNumber - 1, dayNumber);
    if (
        dateObj.getFullYear() !== yearNumber ||
        dateObj.getMonth() !== monthNumber - 1 ||
        dateObj.getDate() !== dayNumber ||
        yearNumber < 1900 || yearNumber > currentYear
    ) {
        return ["The selected Day, Month, and Year do not form a valid date."];
    }
    return null;
}

export {
	formatDatePicker,
	resetDatePickerYear,
	avatarUploader,
	memberFormValidation,
	ajaxFormValidation,
	birthDateValidationCallback,
};
